---
title: 动态规划
mathjax: true
date: 2021-11-08 08:43:52
categories:
- 算法
tags:
---

> 写在前面，看了比较多的博文将动态规划的，解决问题的基础都是状态转移方程。这里我个人认为至少有两点需要深入探讨一下，第一个是一个问题为什么可以用动态规划求解，即为什么满足动态规划的三个条件，大家基本上都是默认这个问题可以用动态规划求解，然后给出了状态转移方程；第二个是出口条件的设定，有了公式还不能解决问题，还要考虑当问题到达最小子问题的时候，值为多少。

## 一、例题

1、给出一个数字序列，从中选出不相邻的数字，使得这些数字之和最大。

输入：4 1 1 9 1

输出：13（4和9不相邻，且加起来的和是最大的）

<!--more-->

分析：先定义一个函数F(i)，其中i表示这个数字序列的第i个数字，函数F(i)表示从i个数字中选出不相邻的数字，使得这些数字之和最大。我们每次只需要考虑第i个数字是否选即可。如果我们选择第i个数字作为结果序列的一员，则数字之和为F(i-2)+V(i)，其中V(i)表示第i个数字的值；如果我们不选择第i个数字，则只需要考虑前i-1个数字可以选出的最大的和F(i-1)即可。所以每次我们需要得到max{F(i-1,F(i-2)+V(i)}。这就是我们得到的转移方程。最后再来看一看递归到最底层的时候是怎样的，即考虑F(0)、F(1)和F(2)的值，显然F(0)=0，F(1)=V(1)，而F(2)=max{v(1),v(2)}。

java代码如下：

```java
public int maxSum(int[] arr) {
    int n = arr.length;
    int[] res = new int[n+1];
    res[0] = 0;
    res[1] = arr[0];
    res[2] = Math.max(arr[0],arr[1]);
    for(int i = 3; i < n+1; i++) {
        res[i] = Math.max(res[i-1],res[i-2]+arr[i-1]);
    }
}
```

> 细节：对于动态规划问题，我比较喜欢设置一个哨兵位，即res[0]为哨兵，结果从res[1]开始计算，这样是为了方便计算，res[i]中的i就可以表示实际的第几个数字了，而不用像数组那样，还需要i-1。但是对于给出参数arr，它的第i-1位才表示第i个数字，在编码的时候需要注意一下。

2、给出一个数字序列（值都大于0）和一个目标值T>0，判断这个数字序列中的能否选出和为T的一组数字，能则输出True，否则输出False。

输入：3 34 4 12 5 2

输入：9

输出：True（4+5=9）

分析：问题可以简述为前N个数字的和（全部数字或者部分数字之和）能否构成T，此时只需要考虑第N个数字是否要参与和的运算，（1）首先当v(N)==T的时候，则前N个数字一定能够组成T；（2）当v(N)<T的时候，需要考虑N-1个数字能否组成T和N-1个数字能否组成T-v(N)，两者有一个为True则结果为True；（3）当v(N) >T的时候，需要判断前N-1个数字能否构成T即可。

分析可能比较抽象，下面看一个表格。

|      |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  F   |  F   |  F   |  F   |  F   |  F   |  F   |  F   |  F   |  F   |
|  1   |  F   |  F   |  F   |  T   |  F   |  F   |  F   |  F   |  F   |  F   |
|  2   |  F   |  F   |  F   |  T   |  F   |  F   |  F   |  F   |  F   |  F   |
|  3   |  F   |  F   |  F   |  T   |  T   |  F   |  F   |  T   |  F   |  F   |
|  4   |  F   |  F   |  F   |  T   |  T   |  F   |  F   |  T   |  F   |  F   |
|  5   |  F   |  F   |  F   |  T   |  T   |  T   |  F   |  T   |  T   |  T   |
|  6   |  F   |  F   |  T   |  T   |  T   |  T   |  T   |  T   |  T   |  T   |

表头行的每个数字表示目标值（Target），表头列的每个数字代表第几个数字。

首先看第0行，表示只有0个数字，显然不可能组成任何一个数，因此第0行的所有结果均为false，再看第0列，此时表示目标值为0，由于数组中的值都大于0，所以所有结果都为false。接着开始计算，看第一行，第一行表示前1个数字能否组成1、2、3...9，第一个数字的值为3，即v(1)=3>1,2，则根据前文分析中的第三点可以得出，需要看前1-1=0个数能否构成T=9，而前0个数不能构成任何一个数字，所以（1，1）、（1，2）都为false；v(1)=3，根据前文分析的第一点可以得出，前1个数一定能够组成数字3，则（1，3）为true；v(1)=3<4,5,...i,...,9，根据前文分析的第二点，需要考虑前1-1=0个数能否组成T=9和前1-1=0个数能否组成T-i，显然两个条件都为false。

按照上述的分析，一行一行往下计算，最终可以得到上述表格。而我们要的结果则是（6，9）的值，从表格中可以看出，结果为true。

java代码如下：

```java
public boolean isTarget(int[] arr, int target) {
        int n = arr.length;
        boolean[][] res = new boolean[n+1][target+1];

        for (int i = 1; i < n+1; i++) {
            for (int j = 1; j < target+1; j++) {
                if (arr[i-1] == j) {
                    res[i][j] = true;
                }else if (arr[i-1] < j){
                    res[i][j] = res[i-1][j] || res[i-1][j-arr[i-1]];
                }else {
                    res[i][j] = res[i-1][j];
                }
            }
        }
        return res[n][target];
    }
```
3、0-1背包问题

有N件物品和一个容量是V的背包。每件物品只能使用一次。第i件物品的体积是$$v_i$$_，价值是$$w_i$$，求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值最大。输出最大价值。

输入：

4 5
1 2
2 4
3 4
4 5

输出：8

分析：其实问题2即可看作是一个背包问题，这里再次分析一下。将$$N$$个物品放入容量为$$V$$的背包中，每次只需要考虑前$$i$$个物品放入容量为$$V=0,1,2...$$的背包的最大价值即可。直接给出转移方程如下：
$$
F[i][j]=Max{(F[i-1][j],F[i-1][j-w_i])}
$$
公式的含义表示将前i个物品放入容量为$$j$$的背包中的最大价值是多少。在$$w_i<=j$$的情况下，需要考虑第$$i$$个物品是否放入背包两种情况。若不放，则需要知道将前$$i-1$$个物品放入容量为j的背包中的最大价值；若放入，则需要考虑将前$$i-1$$个物品放入容量为$$j-w_i$$的背包中的最大价值。两者取最大值即可。

java代码如下：

解法1：时间复杂度为0(NV)，空间复杂度0(NV)。

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String str = in.nextLine();
        int N = Integer.parseInt(str.split(" ")[0]);
        int V = Integer.parseInt(str.split(" ")[1]);
        
        int[] carr = new int[N+1];
        int[] warr = new int[N+1];
        
        for (int i = 0; i < N; i++) {
            String cAndW = in.nextLine();
            carr[i+1] = Integer.parseInt(cAndW.split(" ")[0]);
            warr[i+1] = Integer.parseInt(cAndW.split(" ")[1]);
        }
        
        int[] res = new int[V+1];
        
        for (int i = 1; i < N+1; i++) {
            for (int j = V; j > 0; j--) {
                if (carr[i] <= j) {
                    res[j] = Math.max(res[j],res[j-carr[i]]+warr[i]);
                }
            }
        }
        System.out.println(res[V]);
        
    } 
}
```

解法2：时间复杂度为0(NV)，空间复杂度0(V)。

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String str = in.nextLine();
        int N = Integer.parseInt(str.split(" ")[0]);
        int V = Integer.parseInt(str.split(" ")[1]);
        
        int[] carr = new int[N+1];
        int[] warr = new int[N+1];
        
        for (int i = 0; i < N; i++) {
            String cAndW = in.nextLine();
            carr[i+1] = Integer.parseInt(cAndW.split(" ")[0]);
            warr[i+1] = Integer.parseInt(cAndW.split(" ")[1]);
        }
        
        int[][] res = new int[N+1][V+1];
        
        for (int i = 1; i < N+1; i++) {
            for (int j = 1; j < V+!; j++) {
                if (carr[i] <= j) {
                    res[i][j] = Math.max(res[i-1][j],res[i-1][j-carr[i]]+warr[i]);
                }else {
                    res[i][j] = res[i-1][j];
                }
            }
        }
        System.out.println(res[N][V]);
        
    } 
}
```





